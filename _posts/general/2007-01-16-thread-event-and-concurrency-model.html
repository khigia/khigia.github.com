---
layout: post-import
title: "Thread, Event, and concurrency model"
categories: ['wp-import', 'general']
wpimport-url: "http://khigia.wordpress.com/2007/01/16/thread-event-and-concurrency-model/"
---
I recently jumped into the <a href="http://www.erlang.org/" title="Erlang.org Homepage" target="_blank">Erlang</a> world, mostly seduced by the message-passing concurrency model (as opposed to the shared-state concurrency model) [1]. This was a choice <strong>a priori</strong> without real objective (I mean without project, just as learning experience).<br/>
Now we have (project in my company) to implement an "efficient" and scalable server: fast, robust and highly-available (as any servers, of course). Coming from a really bad Python threaded-server experience, I'd rather read some hints before to go to any platform or framework (<a href="http://www.stackless.com/" title="Stackless Python Homepage">Stackless Python</a>, <a href="http://twistedmatrix.com/" title="Twisted Framework Homepage">Twisted</a>, Erlang/OTP, Java, C/C++ ...). Here are some available documents related to high performance network servers:
<ul>
	<li><a href="http://www.kegel.com/c10k.html" target="_blank" title="//www.kegel.com/c10k.html" class="externalLink">The C10K problem</a></li>
	<li><a href="http://pl.atyp.us/content/tech/servers.html" target="_blank" title="//pl.atyp.us/content/tech/servers.html" class="externalLink">High Performance Server Architecture</a></li>
	<li><a href="http://www.usenix.org/events/hotos03/tech/vonbehren.html" target="_blank" title="//www.usenix.org/events/hotos03/tech/vonbehren.html" class="externalLink">Why events are a bad idea</a> (with <a href="http://lambda-the-ultimate.org/classic/message10796.html" target="_blank" title="//lambda-the-ultimate.org/classic/message10796.html" class="externalLink">relative comments</a> on <a href="http://lambda-the-ultimate.org/" target="_blank" title="//lambda-the-ultimate.org" class="externalLink">LtU</a>)</li>
</ul>
Wow! that's tough to decide anything! Where I'm a bit surprised is that concurrency model choice is often viewed as <span style="font-weight:bold;">Thread vs. Event</span>, and each side argue about <span style="font-style:italic;">throughput</span> , <span style="font-style:italic;">switching context cost</span>, and <span style="font-style:italic;">latency</span>. As I understand, message-passing and event is not the same: most of the event model I've seen do not enable pre-emption without relying on threads to manage some event loops. And I naively assume that pre-emption is a good choice to implement robust and available server.<br/>
To conclude, if I have to choose something today, I would still choose Erlang! Because it implements efficient lightweight process: easy as threads, message passing model, and pre-emption able [2]. Furthermore Erlang proposes through OTP a whole framework for robust application, and I see a (good) framework as an invaluable experienced-user knowledge (thank you OTP folks!).<br/>
Notes:
[1] Indeed Erlang feature an efficient implementation of so-called processes (also known as lightweight-thread, micro-thread, greenlet or tasklet ... but the term process emphasize on the absence of shared-state common to many thread implementation). Erlang made also the choice of functional programming style as a programming guide to context independent code (unique affectation of variable, reduced side-effects).<br/>
[2] Having a lot of Python code, I had to compared Erlang vs. Stackless Python. In fact they share a lot of characteristics but Stackless has not the whole OTP framework and more importantly Stackless message sending block if there is no receptor of the message (more in <a href="http://programming.reddit.com/info/u2ng/comments" target="_blank" title="//programming.reddit.com/info/u2ng/comments" class="externalLink">this discussion</a> about Stackless vs. Erlang).